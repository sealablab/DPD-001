# 003

## Overview

[Description of this document]

## See Also

---
**View this document:**
- üìñ [Obsidian Publish](https://publish.obsidian.md/dpd-001/handoffs/20251126/003)
- üíª [GitHub](https://github.com/sealablab/DPD-001/blob/main/handoffs/20251126/003.md)
- ‚úèÔ∏è [Edit on GitHub](https://github.com/sealablab/DPD-001/edit/main/handoffs/20251126/003.md)
## Q1: Edge Detection Metadata

  
Q1: Excellent choices. On top of your suggestions  I propose the following:
- 'letter' : (i.e. 'A' (Armed) 'F' (Fault))
- - 'name:' 'Armed' 'Fault'
- - descr:' 'Probe will respond to triggers'

It is good to include this here, as even if the test infrastructure does not know or care (these are mostly freeform) 'higher level' tools that generate a UI can use it!

  
  # 003

## Overview

[Description of this document]

## See Also

---
**View this document:**
- üìñ [Obsidian Publish](https://publish.obsidian.md/dpd-001/handoffs/20251126/003)
- üíª [GitHub](https://github.com/sealablab/DPD-001/blob/main/handoffs/20251126/003.md)
- ‚úèÔ∏è [Edit on GitHub](https://github.com/sealablab/DPD-001/edit/main/handoffs/20251126/003.md)

## Q2: Register Class Propagation

  Should the YAML explicitly define the sync-safe gating rule?
  Yes. We should **absolutely** make some sort of 'network-accessible' status here. In fact the vast majority of utilities above the actual .vhd files will __only__ care about the network accessible fields.
  
  ## Q3 How should tests/ consume this YAML? 
  I think A) makes the most sense 

  Q4: Campaign Status Registers

  For CR12-CR13 (read-only status), Moku CloudCompile may have a specific mechanism. Do you know if there's a way to:
  - Read back status registers from the FPGA?
  - Or should we plan to use OutputC/HVS for campaign status initially?
The network **readable** registers are a 'coming soon' feature. The best we can do is plan appropriately, for now we rely on 'live-streaming' OuputC/HVS for pseudo real time processing at the higher level python application layer

  ---
  Summary of Changes from Current State

  | Register   | Current        | Proposed                       |
  |------------|----------------|--------------------------------|
  | CR0[31:29] | FORGE          | FORGE (unchanged)              |
  | CR0[28]    | unused         | campaign_enable (reserved)     |
  | CR0[2]     | unused         | arm_enable                     |
  | CR0[1]     | unused         | fault_clear (edge, auto-clear) |
  | CR0[0]     | sw_trigger     | sw_trigger (edge, auto-clear)  |
  | CR1[0:4]   | lifecycle bits | UNUSED (reserved for campaign) |
  | CR8[2]     | unused         | auto_rearm_enable              |

  Does this structure look right? Any field naming or bit position preferences before I draft the full YAML and RTL changes?




  Questions Before Implementation

## Q1: Bit Position Confirmation
Looks great!

## Q2: Letter Assignments

  I assigned single-letter codes for quick reference:
  See below. I made the first three spell 'RUN' üòÖ
  - R = (R)eady (forge_ready)
  - U = (U)ser Enable
  - N = Clock E(N)nable 
  - P = camPaign
  - A = Armed
  - C = Clear fault
  - T = Trigger
  - B = Burst mode


  Q3: Implementation Order
  Agreed
  