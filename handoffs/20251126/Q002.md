---
created: 2025-11-26
modified: 2025-11-28 00:36:25
accessed: 2025-11-29 00:01:24
---

## T1: Overall register relocation
Lets take a minute and clean things up a little more. To be clear: This is a **100%** API breaking change point. We have no backwards compatability to honor other than the lessors we have learned along the way.

## Q1: Campaign mode register reservation:
Yes!! Lets stake out a clear register allocation for this now, even if we will leave the implementation TBD. We can make this all look and feel consistent. 

> [!NOTE]The moku applications allow a primitive GUI form of bit-flipping these CR's. 
> That is why the **most important bits** start at CR0[31:29] and move downward. There is a generally 'usability' feature in that if a user starts flipping zeros to ones in gui from left to right, generally the sooner they see something observable happen, the better,
> 


 ##  Q2: Hardware Trigger Gating

  With hw_trigger_enable removed, the InputA comparator will be active whenever global_enable is true. This means:

  - Armed + InputA crosses threshold → FSM fires
  - Not armed + InputA crosses threshold → ignored (FSM not in ARMED state)

  Is this acceptable? 
Yes: This is the desired behavior. The end-users are expected to know that 'ARMED' is synonymous with 'input triggering:enabled' 
The topmost FORGE bits, although well defined, are essentially to be seen to the end users as a 'safety' feature specifically to prevent bitstreams from 'running' with a fresh slate of zero'd CR's straight after instrument reset.

## Q3: Edge-Detected Bit Ergonomics ?
AKA: Should we add a hardware "pulse stretcher" that auto-clears internally after N cycles? 
I think __yes__ but: 
We would also have to track these specially inside the shadow register backend inside @tests. 

## Proposal: What if we identify these in the @BPD-RTL.yaml
.. 
That way, we could
a) feed the yml file in to @tests/ backend, and __it__ could then configure the shadow register file and manage them from a signal authoritative source

